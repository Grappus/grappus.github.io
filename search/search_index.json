{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Grappus Development Guidelines The objective of this website is to follow and maintain a uniform convention and rules to follow while developing which is applicable across all teams. Best practices Common best practices that we intend to follow: Use Git properly: It helps in maintaining proper workflow and keeps track of changes in source code over time. Follow standard naming conventions. Use file templates in your IDE to avoid doing the same thing, again and again, such as Live templates in Intellij. Follow common practices and IDE and Indentation settings across the team. Put comments in ad-hoc logic. Follow the latest architecture pattern. Use RX where ever possible to save time and write less code. Set up CI/CD for ease of integration and distribution of builds. Writing Meaningful Names: The following is an excerpt from Clean Code: A Handbook of Agile Software Craftsmanship (Robert C. Martin). Names are everywhere in software. We name our variables, our functions, our arguments, classes, and packages. Use Intention-Revealing Names: It is easy to say that names should reveal intent. Choosing good names takes time but saves more than it takes. So take care of your names and change them when you find better ones. Everyone who reads your code (including you) will be happier if you do. You should name a variable using the same care with which you name a first-born child. The name of a variable, function, or class, should answer all the big questions. It should tell you why it exists, what it does, and how it is used. If a name requires a comment, then the name does not reveal its intent. int d; // elapsed time in days If a name needs a comment to describe itself then it is not a good name. The name d reveals nothing. It does not evoke a sense of elapsed time, nor days. We should choose a name that specifies what is being measured and the unit of that measurement: int elapsedTimeInDays; int daysSinceCreation; int daysSinceModification; int fileAgeInDays; Add Meaningful Context: There are a few names which are meaningful in and of themselves\u2014most are not. Instead, you need to place names in context for your reader by enclosing them in well-named classes, functions, or namespaces. Imagine that you have variables named firstName, lastName, street, houseNumber, city, state, and zipcode. Taken together it\u2019s pretty clear that they form an address. But what if you just saw the state variable being used alone in a method? Would you automatically infer that it was part of an address? Writing Functions: Small! : The first rule of functions is that they should be small. The second rule of functions is that they should be smaller than that. Do One Thing : Functions should do one thing. They should do it well. They should do it only. Function Arguments : The ideal number of arguments for a function is zero (niladic). Next comes one (monadic), followed closely by two (dyadic). Three arguments (triadic) should be avoided where possible. More than three (polyadic) requires very special justification\u2014and then shouldn\u2019t be used anyway. When a function seems to need more than two or three arguments, it is likely that some of those arguments ought to be wrapped into a class of their own. Whenever you are doing some conditional operations such as switch statements and inside that, if any operation takes up more than 3 lines, extract that operation into a separate meaning function. Prefer Exceptions to Returning Error Codes: Try to not to return a default value if any condition does not satisfy the pre-known clauses, return an exception instead so that the caller of that function can handle unknown cases accordingly. Comments: Nothing can be quite so helpful as a well-placed comment. Nothing can clutter up a module more than frivolous dogmatic comments. Nothing can be quite so damaging as an old crufty comment that propagates lies and misinformation. It is sometimes useful to provide basic information with a comment but most of the time they can be eliminated by the use of good names. For example: // Check to see if the employee is eligible for full benefits if ((employee.flags & HOURLY_FLAG) && (employee.age > 65)) Don\u2019t Use a Comment When You Can Use a Function or a Variable. The above is comment is unnecessary and can be easily avoided by extracting to a separate function. if (employee.isEligibleForFullBenefits()) TODO Comments: TODOs are jobs that the programmer thinks should be done, but for some reason can\u2019t do at the moment. It might be a reminder to delete a deprecated feature or a plea for someone else to look at a problem. It might be a request for someone else to think of a better name or a reminder to make a change that is dependent on a planned event. Whatever else a TODO might be, it is not an excuse to leave bad code in the system. Every TODO comment should include the following things: 1. Name of the person writing the TODO. 2. Why is he writing a TODO? 3. When does he expect to remove it? Commented-Out Code Few practices are as odious as commenting-out code. Don\u2019t do this! InputStreamResponse response = new InputStreamResponse(); response.setBody(formatter.getResultStream(), formatter.getByteCount()); // InputStream resultsStream = formatter.getResultStream(); // StreamReader reader = new StreamReader(resultsStream); // response.setContent(reader.read(formatter.getByteCount())); Others who see that commented-out code won\u2019t have the courage to delete it. They\u2019ll think it is there for a reason and is too important to delete. So commented-out code gathers like dregs at the bottom of a bad bottle of wine. Formatting: When people look under the hood, we want them to be impressed with the neatness, consistency, and attention to detail that they perceive. We want them to be struck by the orderliness. We want their eyebrows to rise as they scroll through the modules. We want them to perceive that professionals have been at work. You should take care that your code is nicely formatted. You should choose a set of simple rules that govern the format of your code, and then you should consistently apply those rules. If you are working on a team, then the team should agree to a single set of formatting rules and all members should comply. It helps to have an automated tool that can apply those formatting rules for you. The Purpose of Formatting : First of all, let\u2019s be clear. Code formatting is important. It is too important to ignore and it is too important to treat religiously. Code formatting is about communication, and communication is the professional developer\u2019s first order of business.","title":"Home"},{"location":"#grappus-development-guidelines","text":"The objective of this website is to follow and maintain a uniform convention and rules to follow while developing which is applicable across all teams.","title":"Grappus Development Guidelines"},{"location":"#best-practices","text":"","title":"Best practices"},{"location":"#common-best-practices-that-we-intend-to-follow","text":"Use Git properly: It helps in maintaining proper workflow and keeps track of changes in source code over time. Follow standard naming conventions. Use file templates in your IDE to avoid doing the same thing, again and again, such as Live templates in Intellij. Follow common practices and IDE and Indentation settings across the team. Put comments in ad-hoc logic. Follow the latest architecture pattern. Use RX where ever possible to save time and write less code. Set up CI/CD for ease of integration and distribution of builds.","title":"Common best practices that we intend to follow:"},{"location":"#writing-meaningful-names","text":"The following is an excerpt from Clean Code: A Handbook of Agile Software Craftsmanship (Robert C. Martin). Names are everywhere in software. We name our variables, our functions, our arguments, classes, and packages.","title":"Writing Meaningful Names:"},{"location":"#use-intention-revealing-names","text":"It is easy to say that names should reveal intent. Choosing good names takes time but saves more than it takes. So take care of your names and change them when you find better ones. Everyone who reads your code (including you) will be happier if you do. You should name a variable using the same care with which you name a first-born child. The name of a variable, function, or class, should answer all the big questions. It should tell you why it exists, what it does, and how it is used. If a name requires a comment, then the name does not reveal its intent. int d; // elapsed time in days If a name needs a comment to describe itself then it is not a good name. The name d reveals nothing. It does not evoke a sense of elapsed time, nor days. We should choose a name that specifies what is being measured and the unit of that measurement: int elapsedTimeInDays; int daysSinceCreation; int daysSinceModification; int fileAgeInDays;","title":"Use Intention-Revealing Names:"},{"location":"#add-meaningful-context","text":"There are a few names which are meaningful in and of themselves\u2014most are not. Instead, you need to place names in context for your reader by enclosing them in well-named classes, functions, or namespaces. Imagine that you have variables named firstName, lastName, street, houseNumber, city, state, and zipcode. Taken together it\u2019s pretty clear that they form an address. But what if you just saw the state variable being used alone in a method? Would you automatically infer that it was part of an address?","title":"Add Meaningful Context:"},{"location":"#writing-functions","text":"Small! : The first rule of functions is that they should be small. The second rule of functions is that they should be smaller than that. Do One Thing : Functions should do one thing. They should do it well. They should do it only. Function Arguments : The ideal number of arguments for a function is zero (niladic). Next comes one (monadic), followed closely by two (dyadic). Three arguments (triadic) should be avoided where possible. More than three (polyadic) requires very special justification\u2014and then shouldn\u2019t be used anyway. When a function seems to need more than two or three arguments, it is likely that some of those arguments ought to be wrapped into a class of their own. Whenever you are doing some conditional operations such as switch statements and inside that, if any operation takes up more than 3 lines, extract that operation into a separate meaning function.","title":"Writing Functions:"},{"location":"#prefer-exceptions-to-returning-error-codes","text":"Try to not to return a default value if any condition does not satisfy the pre-known clauses, return an exception instead so that the caller of that function can handle unknown cases accordingly.","title":"Prefer Exceptions to Returning Error Codes:"},{"location":"#comments","text":"Nothing can be quite so helpful as a well-placed comment. Nothing can clutter up a module more than frivolous dogmatic comments. Nothing can be quite so damaging as an old crufty comment that propagates lies and misinformation. It is sometimes useful to provide basic information with a comment but most of the time they can be eliminated by the use of good names. For example: // Check to see if the employee is eligible for full benefits if ((employee.flags & HOURLY_FLAG) && (employee.age > 65)) Don\u2019t Use a Comment When You Can Use a Function or a Variable. The above is comment is unnecessary and can be easily avoided by extracting to a separate function. if (employee.isEligibleForFullBenefits())","title":"Comments:"},{"location":"#todo-comments","text":"TODOs are jobs that the programmer thinks should be done, but for some reason can\u2019t do at the moment. It might be a reminder to delete a deprecated feature or a plea for someone else to look at a problem. It might be a request for someone else to think of a better name or a reminder to make a change that is dependent on a planned event. Whatever else a TODO might be, it is not an excuse to leave bad code in the system. Every TODO comment should include the following things: 1. Name of the person writing the TODO. 2. Why is he writing a TODO? 3. When does he expect to remove it?","title":"TODO Comments:"},{"location":"#commented-out-code","text":"Few practices are as odious as commenting-out code. Don\u2019t do this! InputStreamResponse response = new InputStreamResponse(); response.setBody(formatter.getResultStream(), formatter.getByteCount()); // InputStream resultsStream = formatter.getResultStream(); // StreamReader reader = new StreamReader(resultsStream); // response.setContent(reader.read(formatter.getByteCount())); Others who see that commented-out code won\u2019t have the courage to delete it. They\u2019ll think it is there for a reason and is too important to delete. So commented-out code gathers like dregs at the bottom of a bad bottle of wine.","title":"Commented-Out Code"},{"location":"#formatting","text":"When people look under the hood, we want them to be impressed with the neatness, consistency, and attention to detail that they perceive. We want them to be struck by the orderliness. We want their eyebrows to rise as they scroll through the modules. We want them to perceive that professionals have been at work. You should take care that your code is nicely formatted. You should choose a set of simple rules that govern the format of your code, and then you should consistently apply those rules. If you are working on a team, then the team should agree to a single set of formatting rules and all members should comply. It helps to have an automated tool that can apply those formatting rules for you. The Purpose of Formatting : First of all, let\u2019s be clear. Code formatting is important. It is too important to ignore and it is too important to treat religiously. Code formatting is about communication, and communication is the professional developer\u2019s first order of business.","title":"Formatting:"},{"location":"android/","text":"Android Guidelines Setting up a new project Server Side While following every step mentioned in git here , there is a small additional step you need to follow: In bitbucket go to Settings->PULL REQUESTS->Default description and paste the following content: ## Description ### Why was this change necessary? [text here] ### How does it address the problem? [text here] ### Are there any side effects? [text here] ### Do you want any specific feedback? [text here] ### Do you have resources that will help the reviewer? [MP-](https://grappus.atlassian.net/browse/MP-) ### Zeplin screen design links? [link here] ### Did you run `./gradlew spotlessApply; ./gradlew testDebugUnitTestCoverage;` locally? [yes/no] Client Side Setting up a new project takes up a lot of effort and forgetting up some edge cases is pretty normal which may lead to some fatal errors which can lead to some serious issues to be handled later. We have done this job for you. Follow along to see the process. Clone our base project from here . Change the required package name. While working with multiple modules few things to keep in mind with the modules package name. For example, take com.android as the base package name: (i) The package name of the app module should be com.android . (ii) Package name of api module should be com.android.api . (iii) Package name of core module should be com.android.core . (iv) Package name of logic module should be com.android.logic . (v) Ensure that application id in manifest.xml and build.gradle is the same. Naming the packages in this format helps in running test cases with Jacoco . Change the API response structure according to your needs in this file and amend it's test class accordingly in your local project. Format the code by running ./gradlew spotlessApply command and run tests by running ./gradlew testDebugUnitTestCoverage . If the above command fails, ensure that you are on java version 1.8 and if not please upgrade or degrade your java version. Degrading java version can be done by running export JAVA_HOME=$(/usr/libexec/java_home -v 1.8) in terminal. More details here . Delete the .git folder in your project's root directory. Rename your root project name. Connect your local repo to a remote source. if all the above points run successfully and your build is successful then you are ready to roll. Creating Git Aliases Aliases are used to create shorter commands that map to longer commands. Here are a few handy git aliases you can make to avoid copy and pasting a command again and again. alias prcheck=\"./gradlew spotlessApply; ./gradlew spotlessCheck testDebugUnitTestCoverage;sapply\" : Add this to your bash profile and you can run prcheck in your directory to assert things are fine before submitting a PR. Before you start developing Set up File template in Intellij We have made an Android studio template to create files required for a fragment and it's related files. Download the File template from here and follow the instructions written in Readme.txt inside the newly extracted folder. Navigate to Android Studio and go to File-> Import Settings... and select the settings.zip inside the newly-downloaded file template. After completing the above processes restart Androids studio and you should see file template as seen in the image in the above-downloaded folder. While Developing Few things to remember while developing so that we all can be on the same page. Architecture: We are following a mixture of MVI and MVVM architecture in this project with kotlin as the primary language for development. In this project, we heavily use RxJava , RxKotlin and Live Data for managing asynchronous call in API and database. We manage our dependencies using dagger , code test coverage is maintained using Jacoco and mocking of objects including API response is done using mockito . We strictly follow the Single responsibility principle and therefore this project is divided into 6 modules. core : This module contains all the view model base classes, models for app views and Transport classes for transporting server entities to app models. logic : Logic contains all the view model implementations and App logic. Dagger modules are also defined here only. app : App is the view layer and contains all the views implementation. It also contains dagger components. api : Api layer contains the network related implementations. buildSrc It manages external dependencies for the whole project. local-resources This module is used to hold static JSON responses which can be used for local build-types and testing purposes. Nomenclature : Typacilly each fragment contains 5 Files. * Fragment: The part where UI events are handled. * FragmentBindingModel: The part where UI events processing is done and formatted details are sent to the fragment. * FragmentViewModel: Here the events are processed. It contains all the required data to maintain the state of the fragment. * FragmentHandler: It is an interface where we declare the click listeners of UI events. * FragmentLayout: It contains the UI design code. The naming convention of all files should be as described above just replace the above word Fragment with your desired name. Testcases: Write the test cases of logic module religiously by covering each ViewEvent including api and database calls by asserting their expected and actual view state update before and after the operation. We strictly maintain a minimum of 70% code coverage in our test cases which include branch testing (there should be an if for every else) and instructions testing. Any PR which does not satisfy the minimum test coverage criteria shall not be merged. To see your current coverage: Run ./gradlew testDebugUnitTestCoverage in your terminal. Navigate to the logic module in the Project view in AS. Go to build->reports->jacaco->testDebugUnitTestCoverage->html and open index.html in your browser to see your test code coverage to every file in logic module. Extension functions/properties Kotlin provides the ability to extend a class with new functionality without having to inherit from the class, this is done via special declarations called extensions. We encourage you to write extension functions, primarily in the logic module and writing its test cases vigorously. Here is a small implementation of Datatype Extensions for your reference and it's test cases are written here . Writing comments No need to clutter your code by writing comments for every method but do not forget to write comments whenever you are performing some ad-hoc logic calculation. Do not use random numbers in that method, give them a proper variable name. Use Vector Assets Android Studio includes a tool called Vector Asset Studio that helps you add material icons and import Scalable Vector Graphic (SVG) and Adobe Photoshop Document (PSD) files into your project as vector drawable resources. Using vector drawables instead of bitmaps reduces the size of your APK because the same file can be resized for different screen densities without loss of image quality. For older versions of Android that don't support vector drawables, Vector Asset Studio can, at build time, turn your vector drawables into different bitmap sizes for each screen density. You can read more about it here . Making reusable layouts: Make the layout's reusable by using <include> tag in the layout and pass data to them using data binding. Avoid hard coding: Do not hard code strings in the project. Use them via strings.xml to ease the process of translation in different languages. Using Kotlin only features: We encourage you to use kotlin only features such as sealed classes , extension function, Objects, etc. As said above we heavily use Scope Functions to write clutter-free code and avoid writing the same thing again and again. Please refer to the above link to read more about it. Raising a PR Follow the steps as described in git section . Run prcheck alias in the terminal. If you have made changes only in a single module, squash all your commits into 1 commit. If you have made changes in more than 1 module, please divide your PR into 3 commits i.e data, logic and UI. Following is an example commit message where each commit contains its relevant files. feat(ALT-33): Adds sign in via OTP screen (data). feat(ALT-33): Adds sign in via OTP screen (logic). feat(ALT-33): Adds sign in via OTP screen (UI). Responding to feedback on PR The changes which you have done in your code as suggested in PR comments should be committed separately in a separate commit with the commit message as fix(*): PR suggestions","title":"Android"},{"location":"android/#android-guidelines","text":"","title":"Android Guidelines"},{"location":"android/#setting-up-a-new-project","text":"","title":"Setting up a new project"},{"location":"android/#server-side","text":"While following every step mentioned in git here , there is a small additional step you need to follow: In bitbucket go to Settings->PULL REQUESTS->Default description and paste the following content: ## Description ### Why was this change necessary? [text here] ### How does it address the problem? [text here] ### Are there any side effects? [text here] ### Do you want any specific feedback? [text here] ### Do you have resources that will help the reviewer? [MP-](https://grappus.atlassian.net/browse/MP-) ### Zeplin screen design links? [link here] ### Did you run `./gradlew spotlessApply; ./gradlew testDebugUnitTestCoverage;` locally? [yes/no]","title":"Server Side"},{"location":"android/#client-side","text":"Setting up a new project takes up a lot of effort and forgetting up some edge cases is pretty normal which may lead to some fatal errors which can lead to some serious issues to be handled later. We have done this job for you. Follow along to see the process. Clone our base project from here . Change the required package name. While working with multiple modules few things to keep in mind with the modules package name. For example, take com.android as the base package name: (i) The package name of the app module should be com.android . (ii) Package name of api module should be com.android.api . (iii) Package name of core module should be com.android.core . (iv) Package name of logic module should be com.android.logic . (v) Ensure that application id in manifest.xml and build.gradle is the same. Naming the packages in this format helps in running test cases with Jacoco . Change the API response structure according to your needs in this file and amend it's test class accordingly in your local project. Format the code by running ./gradlew spotlessApply command and run tests by running ./gradlew testDebugUnitTestCoverage . If the above command fails, ensure that you are on java version 1.8 and if not please upgrade or degrade your java version. Degrading java version can be done by running export JAVA_HOME=$(/usr/libexec/java_home -v 1.8) in terminal. More details here . Delete the .git folder in your project's root directory. Rename your root project name. Connect your local repo to a remote source. if all the above points run successfully and your build is successful then you are ready to roll.","title":"Client Side"},{"location":"android/#creating-git-aliases","text":"Aliases are used to create shorter commands that map to longer commands. Here are a few handy git aliases you can make to avoid copy and pasting a command again and again. alias prcheck=\"./gradlew spotlessApply; ./gradlew spotlessCheck testDebugUnitTestCoverage;sapply\" : Add this to your bash profile and you can run prcheck in your directory to assert things are fine before submitting a PR.","title":"Creating Git Aliases"},{"location":"android/#before-you-start-developing","text":"","title":"Before you start developing"},{"location":"android/#set-up-file-template-in-intellij","text":"We have made an Android studio template to create files required for a fragment and it's related files. Download the File template from here and follow the instructions written in Readme.txt inside the newly extracted folder. Navigate to Android Studio and go to File-> Import Settings... and select the settings.zip inside the newly-downloaded file template. After completing the above processes restart Androids studio and you should see file template as seen in the image in the above-downloaded folder.","title":"Set up File template in Intellij"},{"location":"android/#while-developing","text":"Few things to remember while developing so that we all can be on the same page.","title":"While Developing"},{"location":"android/#architecture","text":"We are following a mixture of MVI and MVVM architecture in this project with kotlin as the primary language for development. In this project, we heavily use RxJava , RxKotlin and Live Data for managing asynchronous call in API and database. We manage our dependencies using dagger , code test coverage is maintained using Jacoco and mocking of objects including API response is done using mockito . We strictly follow the Single responsibility principle and therefore this project is divided into 6 modules. core : This module contains all the view model base classes, models for app views and Transport classes for transporting server entities to app models. logic : Logic contains all the view model implementations and App logic. Dagger modules are also defined here only. app : App is the view layer and contains all the views implementation. It also contains dagger components. api : Api layer contains the network related implementations. buildSrc It manages external dependencies for the whole project. local-resources This module is used to hold static JSON responses which can be used for local build-types and testing purposes.","title":"Architecture:"},{"location":"android/#nomenclature","text":"Typacilly each fragment contains 5 Files. * Fragment: The part where UI events are handled. * FragmentBindingModel: The part where UI events processing is done and formatted details are sent to the fragment. * FragmentViewModel: Here the events are processed. It contains all the required data to maintain the state of the fragment. * FragmentHandler: It is an interface where we declare the click listeners of UI events. * FragmentLayout: It contains the UI design code. The naming convention of all files should be as described above just replace the above word Fragment with your desired name.","title":"Nomenclature :"},{"location":"android/#testcases","text":"Write the test cases of logic module religiously by covering each ViewEvent including api and database calls by asserting their expected and actual view state update before and after the operation. We strictly maintain a minimum of 70% code coverage in our test cases which include branch testing (there should be an if for every else) and instructions testing. Any PR which does not satisfy the minimum test coverage criteria shall not be merged. To see your current coverage: Run ./gradlew testDebugUnitTestCoverage in your terminal. Navigate to the logic module in the Project view in AS. Go to build->reports->jacaco->testDebugUnitTestCoverage->html and open index.html in your browser to see your test code coverage to every file in logic module.","title":"Testcases:"},{"location":"android/#extension-functionsproperties","text":"Kotlin provides the ability to extend a class with new functionality without having to inherit from the class, this is done via special declarations called extensions. We encourage you to write extension functions, primarily in the logic module and writing its test cases vigorously. Here is a small implementation of Datatype Extensions for your reference and it's test cases are written here .","title":"Extension functions/properties"},{"location":"android/#writing-comments","text":"No need to clutter your code by writing comments for every method but do not forget to write comments whenever you are performing some ad-hoc logic calculation. Do not use random numbers in that method, give them a proper variable name.","title":"Writing comments"},{"location":"android/#use-vector-assets","text":"Android Studio includes a tool called Vector Asset Studio that helps you add material icons and import Scalable Vector Graphic (SVG) and Adobe Photoshop Document (PSD) files into your project as vector drawable resources. Using vector drawables instead of bitmaps reduces the size of your APK because the same file can be resized for different screen densities without loss of image quality. For older versions of Android that don't support vector drawables, Vector Asset Studio can, at build time, turn your vector drawables into different bitmap sizes for each screen density. You can read more about it here .","title":"Use Vector Assets"},{"location":"android/#making-reusable-layouts","text":"Make the layout's reusable by using <include> tag in the layout and pass data to them using data binding.","title":"Making reusable layouts:"},{"location":"android/#avoid-hard-coding","text":"Do not hard code strings in the project. Use them via strings.xml to ease the process of translation in different languages.","title":"Avoid hard coding:"},{"location":"android/#using-kotlin-only-features","text":"We encourage you to use kotlin only features such as sealed classes , extension function, Objects, etc. As said above we heavily use Scope Functions to write clutter-free code and avoid writing the same thing again and again. Please refer to the above link to read more about it.","title":"Using Kotlin only features:"},{"location":"android/#raising-a-pr","text":"Follow the steps as described in git section . Run prcheck alias in the terminal. If you have made changes only in a single module, squash all your commits into 1 commit. If you have made changes in more than 1 module, please divide your PR into 3 commits i.e data, logic and UI. Following is an example commit message where each commit contains its relevant files. feat(ALT-33): Adds sign in via OTP screen (data). feat(ALT-33): Adds sign in via OTP screen (logic). feat(ALT-33): Adds sign in via OTP screen (UI).","title":"Raising a PR"},{"location":"android/#responding-to-feedback-on-pr","text":"The changes which you have done in your code as suggested in PR comments should be committed separately in a separate commit with the commit message as fix(*): PR suggestions","title":"Responding to feedback on PR"},{"location":"git/","text":"Git We use git to help us manage changes to our source code over time. Follow along to get some insights about our workflow. If you are new to git, please read the following blogs to get started: Git basics Try Git Style Guide Merging vs. Rebasing Rebasing a Pull Request Setting up a new project Setting up a remote repository We use Bitbucket for web-based version control repository hosting service, so if not already done Create a new project in Bitbucket. Create a new repository in the newly created project. Create a new branch named develop . Navigate to Settings -> Workflow -> Branch permissions . (i) Create branch permission for branch develop and master . (ii)Uncheck the Allow rewriting branch history and Allow deleting this branch checkbox for both the branches. (iii) Onboard your team. master stable branch and should only be used for client and production releases. develop should always be the latest stable branch where all development PR's would be sent to. Creating a PR template PR template helps us to remind of some things which are essential for the project's sanity to be maintained. While working with the team we all must follow some basic rules and provide useful information to the reviewer. If you are an admin of the repository Go to Settings . Under the PULL REQUESTS heading, click Default description and paste the following content. ## Description ### Why was this change necessary? [text here] ### How does it address the problem? [text here] ### Are there any side effects? [text here] ### Do you want any specific feedback? [text here] ### Do you have resources that will help the reviewer? [MP-](https://messengerpro.atlassian.net/browse/MP-) ### Zeplin screen design links? [link here] Change the Jira tickets prefix according to your Jira project and click save. If you have already created your project locally then modify it's .gitignore file according to you and connect your local project to remote repository else clone the project to your local machine . Connecting your web repository to the project management tool. We use Jira as our project management tool. Please contact your project manager to set up workflows which will help in automating issue/ticket tracking process. Jira Linking Generally, all of your tasks are mentioned in the project management tool. This helps in keeping a record of the productive time you spend working for the company. Branch Naming Git branches are effectively a pointer to a snapshot of your changes. When you want to add a new feature or fix a bug\u2014no matter how big or how small\u2014you spawn a new branch to encapsulate your changes. If you have not created a new branch till yet go ahead and create one. Type the following command to create a new branch git checkout -b {$new_branch _name} Most of the time branched should be created by your issue/ticket number in Jira. {$your_jira_project_prefix} {$dash} {$issue_number} Here are a few examples of how the branch should be named. Ideally, you should work with one ticket at a time, raise its PR to develop and pick another one but if the issue is too small or it takes little time and effort to fix, you can pick multiple tickets at a time. Below are some sample branch names. Working with a single ticket at a time ALT-223 QQ-54 INFLCR-223 Working with multiple tickets at a time ALT-223-ALT-224-ALT-305 QQ-54-QQ-125-QQ-87 INFLCR-223-INFLCR-25 However, if you happen to work on an issue which is not on Jira yet, convey this to your project manager to put that on Jira and in the meanwhile, you can create a branch like chores-AddErrorHandler fix-SplashAnimationFix feat-AddContinueButtonInWishlistScreen If before raising your PR the ticket is created, rename your branch using git branch -m {$new-name} Commit message format We follow a strict specific commit format so that every commit message is well-formatted and self-explanatory. It helps the reviewer or teammate to quickly understand the intention of the commit and provide feedback accordingly. Below are some sample commit message, their structure, and explanation of them. feat(ALT-653): Add continue button in the login screen to navigate to next page fix(INL-345): Fix Splash screen animation bug chores(*) : Add progaurd rules, base project set up This commit message is divided into 4 sections: <type>(<scope>): <subject> <BLANK LINE> <body> Type Description feat() This essentially represents that your commit will add a feature. fix() This represents that your commit will fix a bug. chores() This represents that your commit is doing some project structure related work. docs() Documentation only changes. test() Add missing tests. refactor() A code change that neither fixes a bug or adds a feature. perf() A code change that improves performance. Type : These represent the type of feature or fix your commit will do. Scope : This could be anything defining the place of change a commit. Usually, it can be the ticket number you are working on. If there is no ticket assigned you can replace it with an asterisk * . Subject : This is a short yet meaningful description of your commit. Below are few points to keep in mind for a descriptive commit message. Capitalize the first letter. Limit the subject line to 50 characters. Do not end the subject line with a period(.). Use the imperative mood in the subject line. For example: Fix Splash animation bug not Fixes Splash animation bug nor Fixed Splash animation bug . Body : Body in a commit message is used to describe changes in your commit in a more descriptive way. Although it is not always compulsory to write body in every commit message but it is a good practice to write it to explain your changes. Here is how you can write a commit message body. Write git commit command without any flags. It will open your pre-configured editor. If the editor is vim then enter insert mode by pressing i or insert key . Enter your precise commit message in the first line. Leave a blank line. Enter the description body of your changes. Press Esc and then press :wq to save and quit the editor. Raising a PR Few important things to remember while raising your PR to be merged so that we all can benefit from it and it's important to follow some standard conventions while creating pull requests: Before creating a pull request We follow the concept of rebase to maintain a linear project history of git tree and clean branching model, so it is important to squash your commits and rebase with develop branch. Do not hesitate to push your work regularly to the cloud, but after completing your task combine your commits into minimum meaningful commits. Note: Do not try to squash the commits of develop , master or whichever branch on which multiple people are working on. Their commit history and integrity should be maintained. Here are a few steps you can follow to achieve the same. Commit all your work. Count the number of commits you want to squash using git log --oneline . Start an interactive rebase session by typing git rebase -i HEAD~{$number_of_commits_to_squash} in terminal. In the window pick or squash the commits using p or s after entering insert mode. If the conflicts occur resolve them using git mergetool . After resolving the conflicts add them using git add . and continue rebasing them using git rebase --continue . Read the above-described process in detail here . Pro-tip : You can also achieve the above same process using git reset HEAD~{$number_of_commits_to_squash} . It avoids conflicts by simply un-committing your work and then you can simply combine your work in a single commit. git pull --rebase origin develop Rebase your branch from develop Checkout to develop branch. Update your local branch using git pull origin develop . Checkout to your branch and run git rebase develop . Resolve your conflicts if any using the above-described process. Force push your changes using git push -f origin {$branch_name} Follow and maintain below points in your PR for it to be reviewed Your PR should be small and specific to a unit or granular task. If you have implemented anything new, please mention the relevant links to it. The code contained within will meet the best practices set by the team wherever possible. Write your test cases vigorously. Fill the description form, add all your working teammates as reviewers so that every person is aware of changes in the code base and hit the Create PR button. Reviewing a PR Having proper communication on the internet for the benefit of the project is one of the most important aspects of the project. Following practices collected from Github's blog and other sources should be followed. Ask, don\u2019t tell. (\u201cWhat do you think about trying\u2026?\u201d rather than \u201cDon\u2019t do\u2026\u201d). If you disagree strongly, consider giving it a few minutes before responding; think before you react. Explain your reasons why code should be changed. (Not in line with the style guide? A personal preference?) Offer ways to simplify or improve code. Avoid using derogatory terms, like \u201cstupid\u201d, when referring to the work someone has produced. Be humble. (\u201cI\u2019m not sure, let\u2019s try\u2026\u201d). Avoid hyperbole. (\u201cNEVER do\u2026\u201d). Aim to develop professional skills, group knowledge, and product quality, through group critique. Be aware of negative bias with online communication. (If the content is neutral, we assume the tone is negative.) Can you use positive language as opposed to neutral?. Use emoji to clarify tone. Compare \u201c:sparkles: :sparkles: Looks good :+1: :sparkles: :sparkles:\u201d to \u201cLooks good.\u201d Responding to feedback on Pull Requests Don't take it personally. The review is of the code, not you. Be grateful for the reviewer's suggestions. (\"Good call. I'll make that change.\") Try to respond to every comment. Consider leading with an expression of appreciation, especially when feedback has been mixed. Best Practices Rebase is preferred to merge as it keeps the tree compact. Rebase your working branch before you start working and before you create a pull request. Always push your commits at the end of the day, so in case of emergency, other team members can pick up where you left.","title":"Git"},{"location":"git/#git","text":"We use git to help us manage changes to our source code over time. Follow along to get some insights about our workflow. If you are new to git, please read the following blogs to get started: Git basics Try Git Style Guide Merging vs. Rebasing Rebasing a Pull Request","title":"Git"},{"location":"git/#setting-up-a-new-project","text":"","title":"Setting up a new project"},{"location":"git/#setting-up-a-remote-repository","text":"We use Bitbucket for web-based version control repository hosting service, so if not already done Create a new project in Bitbucket. Create a new repository in the newly created project. Create a new branch named develop . Navigate to Settings -> Workflow -> Branch permissions . (i) Create branch permission for branch develop and master . (ii)Uncheck the Allow rewriting branch history and Allow deleting this branch checkbox for both the branches. (iii) Onboard your team. master stable branch and should only be used for client and production releases. develop should always be the latest stable branch where all development PR's would be sent to.","title":"Setting up a remote repository"},{"location":"git/#creating-a-pr-template","text":"PR template helps us to remind of some things which are essential for the project's sanity to be maintained. While working with the team we all must follow some basic rules and provide useful information to the reviewer. If you are an admin of the repository Go to Settings . Under the PULL REQUESTS heading, click Default description and paste the following content. ## Description ### Why was this change necessary? [text here] ### How does it address the problem? [text here] ### Are there any side effects? [text here] ### Do you want any specific feedback? [text here] ### Do you have resources that will help the reviewer? [MP-](https://messengerpro.atlassian.net/browse/MP-) ### Zeplin screen design links? [link here] Change the Jira tickets prefix according to your Jira project and click save. If you have already created your project locally then modify it's .gitignore file according to you and connect your local project to remote repository else clone the project to your local machine .","title":"Creating a PR template"},{"location":"git/#connecting-your-web-repository-to-the-project-management-tool","text":"We use Jira as our project management tool. Please contact your project manager to set up workflows which will help in automating issue/ticket tracking process. Jira Linking Generally, all of your tasks are mentioned in the project management tool. This helps in keeping a record of the productive time you spend working for the company.","title":"Connecting your web repository to the project management tool."},{"location":"git/#branch-naming","text":"Git branches are effectively a pointer to a snapshot of your changes. When you want to add a new feature or fix a bug\u2014no matter how big or how small\u2014you spawn a new branch to encapsulate your changes. If you have not created a new branch till yet go ahead and create one. Type the following command to create a new branch git checkout -b {$new_branch _name} Most of the time branched should be created by your issue/ticket number in Jira. {$your_jira_project_prefix} {$dash} {$issue_number}","title":"Branch Naming"},{"location":"git/#here-are-a-few-examples-of-how-the-branch-should-be-named","text":"Ideally, you should work with one ticket at a time, raise its PR to develop and pick another one but if the issue is too small or it takes little time and effort to fix, you can pick multiple tickets at a time. Below are some sample branch names.","title":"Here are a few examples of how the branch should be named."},{"location":"git/#working-with-a-single-ticket-at-a-time","text":"ALT-223 QQ-54 INFLCR-223","title":"Working with a single ticket at a time"},{"location":"git/#working-with-multiple-tickets-at-a-time","text":"ALT-223-ALT-224-ALT-305 QQ-54-QQ-125-QQ-87 INFLCR-223-INFLCR-25 However, if you happen to work on an issue which is not on Jira yet, convey this to your project manager to put that on Jira and in the meanwhile, you can create a branch like chores-AddErrorHandler fix-SplashAnimationFix feat-AddContinueButtonInWishlistScreen If before raising your PR the ticket is created, rename your branch using git branch -m {$new-name}","title":"Working with multiple tickets at a time"},{"location":"git/#commit-message-format","text":"We follow a strict specific commit format so that every commit message is well-formatted and self-explanatory. It helps the reviewer or teammate to quickly understand the intention of the commit and provide feedback accordingly. Below are some sample commit message, their structure, and explanation of them. feat(ALT-653): Add continue button in the login screen to navigate to next page fix(INL-345): Fix Splash screen animation bug chores(*) : Add progaurd rules, base project set up This commit message is divided into 4 sections: <type>(<scope>): <subject> <BLANK LINE> <body> Type Description feat() This essentially represents that your commit will add a feature. fix() This represents that your commit will fix a bug. chores() This represents that your commit is doing some project structure related work. docs() Documentation only changes. test() Add missing tests. refactor() A code change that neither fixes a bug or adds a feature. perf() A code change that improves performance. Type : These represent the type of feature or fix your commit will do. Scope : This could be anything defining the place of change a commit. Usually, it can be the ticket number you are working on. If there is no ticket assigned you can replace it with an asterisk * . Subject : This is a short yet meaningful description of your commit. Below are few points to keep in mind for a descriptive commit message. Capitalize the first letter. Limit the subject line to 50 characters. Do not end the subject line with a period(.). Use the imperative mood in the subject line. For example: Fix Splash animation bug not Fixes Splash animation bug nor Fixed Splash animation bug . Body : Body in a commit message is used to describe changes in your commit in a more descriptive way. Although it is not always compulsory to write body in every commit message but it is a good practice to write it to explain your changes. Here is how you can write a commit message body. Write git commit command without any flags. It will open your pre-configured editor. If the editor is vim then enter insert mode by pressing i or insert key . Enter your precise commit message in the first line. Leave a blank line. Enter the description body of your changes. Press Esc and then press :wq to save and quit the editor.","title":"Commit message format"},{"location":"git/#raising-a-pr","text":"Few important things to remember while raising your PR to be merged so that we all can benefit from it and it's important to follow some standard conventions while creating pull requests:","title":"Raising a PR"},{"location":"git/#before-creating-a-pull-request","text":"We follow the concept of rebase to maintain a linear project history of git tree and clean branching model, so it is important to squash your commits and rebase with develop branch. Do not hesitate to push your work regularly to the cloud, but after completing your task combine your commits into minimum meaningful commits. Note: Do not try to squash the commits of develop , master or whichever branch on which multiple people are working on. Their commit history and integrity should be maintained. Here are a few steps you can follow to achieve the same. Commit all your work. Count the number of commits you want to squash using git log --oneline . Start an interactive rebase session by typing git rebase -i HEAD~{$number_of_commits_to_squash} in terminal. In the window pick or squash the commits using p or s after entering insert mode. If the conflicts occur resolve them using git mergetool . After resolving the conflicts add them using git add . and continue rebasing them using git rebase --continue . Read the above-described process in detail here . Pro-tip : You can also achieve the above same process using git reset HEAD~{$number_of_commits_to_squash} . It avoids conflicts by simply un-committing your work and then you can simply combine your work in a single commit. git pull --rebase origin develop Rebase your branch from develop Checkout to develop branch. Update your local branch using git pull origin develop . Checkout to your branch and run git rebase develop . Resolve your conflicts if any using the above-described process. Force push your changes using git push -f origin {$branch_name}","title":"Before creating a pull request"},{"location":"git/#follow-and-maintain-below-points-in-your-pr-for-it-to-be-reviewed","text":"Your PR should be small and specific to a unit or granular task. If you have implemented anything new, please mention the relevant links to it. The code contained within will meet the best practices set by the team wherever possible. Write your test cases vigorously. Fill the description form, add all your working teammates as reviewers so that every person is aware of changes in the code base and hit the Create PR button.","title":"Follow and maintain below points in your PR for it to be reviewed"},{"location":"git/#reviewing-a-pr","text":"Having proper communication on the internet for the benefit of the project is one of the most important aspects of the project. Following practices collected from Github's blog and other sources should be followed. Ask, don\u2019t tell. (\u201cWhat do you think about trying\u2026?\u201d rather than \u201cDon\u2019t do\u2026\u201d). If you disagree strongly, consider giving it a few minutes before responding; think before you react. Explain your reasons why code should be changed. (Not in line with the style guide? A personal preference?) Offer ways to simplify or improve code. Avoid using derogatory terms, like \u201cstupid\u201d, when referring to the work someone has produced. Be humble. (\u201cI\u2019m not sure, let\u2019s try\u2026\u201d). Avoid hyperbole. (\u201cNEVER do\u2026\u201d). Aim to develop professional skills, group knowledge, and product quality, through group critique. Be aware of negative bias with online communication. (If the content is neutral, we assume the tone is negative.) Can you use positive language as opposed to neutral?. Use emoji to clarify tone. Compare \u201c:sparkles: :sparkles: Looks good :+1: :sparkles: :sparkles:\u201d to \u201cLooks good.\u201d","title":"Reviewing a PR"},{"location":"git/#responding-to-feedback-on-pull-requests","text":"Don't take it personally. The review is of the code, not you. Be grateful for the reviewer's suggestions. (\"Good call. I'll make that change.\") Try to respond to every comment. Consider leading with an expression of appreciation, especially when feedback has been mixed.","title":"Responding to feedback on Pull Requests"},{"location":"git/#best-practices","text":"Rebase is preferred to merge as it keeps the tree compact. Rebase your working branch before you start working and before you create a pull request. Always push your commits at the end of the day, so in case of emergency, other team members can pick up where you left.","title":"Best Practices"}]}